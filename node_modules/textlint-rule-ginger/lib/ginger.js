'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _textlintRuleHelper = require('textlint-rule-helper');

var _gingerbread = require('gingerbread');

var _gingerbread2 = _interopRequireDefault(_gingerbread);

var _es6Promisify = require('es6-promisify');

var _es6Promisify2 = _interopRequireDefault(_es6Promisify);

var _textlintUtilToString = require('textlint-util-to-string');

var _textlintUtilToString2 = _interopRequireDefault(_textlintUtilToString);

var _unistUtilMap = require('unist-util-map');

var _unistUtilMap2 = _interopRequireDefault(_unistUtilMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var gingerbreadAsync = (0, _es6Promisify2.default)(_gingerbread2.default);

/**
 * Exclude inappropriate parts of text from linting,
 * such as link texts, image captions, blockquotes, emphasized texts and inline code.
 * @param {TxtNode} node
 * @param {TextLintContext} context
 * @return {{ source: StringSource, text: string }}
 */
function filterNode(_ref) {
  var node = _ref.node;
  var context = _ref.context;
  var Syntax = context.Syntax;

  var helper = new _textlintRuleHelper.RuleHelper(context);

  if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
    return null;
  }

  var filteredNode = (0, _unistUtilMap2.default)(node, function (n) {
    // Replace the value of inline code with a dummy text.
    if (n.type === Syntax.Code) {
      return Object.assign({}, n, { value: 'code' });
    }
    return n;
  });

  var source = new _textlintUtilToString2.default(filteredNode);
  var text = source.toString();

  return { source: source, text: text };
}

function reporter(context) {
  var Syntax = context.Syntax;
  var report = context.report;
  var RuleError = context.RuleError;
  var fixer = context.fixer;


  return _defineProperty({}, Syntax.Paragraph, function (node) {
    return function () {
      var _ref2, source, text, _ref3, _ref4, original, gingered, corrections;

      return Promise.resolve().then(function () {
        _ref2 = filterNode({ node: node, context: context }) || {};
        source = _ref2.source;
        text = _ref2.text;


        if (!(!source || !text)) {
          return Promise.resolve().then(function () {
            return gingerbreadAsync(text);
          }).then(function (_resp) {
            _ref3 = _resp;
            _ref4 = _slicedToArray(_ref3, 3);
            original = _ref4[0];
            gingered = _ref4[1];
            corrections = _ref4[2];

            // when no errors.

            if (!(original === gingered)) {

              corrections.forEach(function (correction) {
                var index = correction.start;
                var originalPosition = source.originalPositionFromIndex(index);
                var originalRange = [originalPosition.column, originalPosition.column + correction.length];
                var fix = fixer.replaceTextRange(originalRange, correction.correct);
                var message = correction.text + ' -> ' + correction.correct;

                report(node, new RuleError(message, {
                  line: originalPosition.line - 1,
                  column: originalPosition.column,
                  fix: fix
                }));
              });
            }
          });
        }
      }).then(function () {});
    }();
  });
}

exports.default = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=ginger.js.map