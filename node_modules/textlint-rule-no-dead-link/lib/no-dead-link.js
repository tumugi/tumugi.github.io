'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * Checks if a given URI is alive or not.
 * @param {string} uri
 * @return {{ ok: bool, message: string }}
 */

let isAlive = (() => {
  var ref = _asyncToGenerator(function* (uri) {
    try {
      const opts = {
        method: 'HEAD',
        // Disable gzip compression in Node.js
        // to avoid the zlib's "unexpected end of file" error
        // https://github.com/request/request/issues/2045
        compress: false
      };
      const res = yield (0, _isomorphicFetch2.default)(uri, opts);

      return {
        ok: res.ok,
        message: `${ res.status } ${ res.statusText }`
      };
    } catch (err) {
      return {
        ok: false,
        message: err.message
      };
    }
  });

  return function isAlive(_x) {
    return ref.apply(this, arguments);
  };
})();

var _textlintRuleHelper = require('textlint-rule-helper');

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

const DEFAULT_OPTIONS = {
  checkRelative: false, // should check relative URLs.
  baseURI: null, // a base URI to resolve a relative URL.
  ignore: [] };

// http://stackoverflow.com/a/3809435/951517
// eslint-disable-next-line max-len
// URIs to be skipped from availability checks.
const URI_REGEXP = /(https?:)?\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g;

/**
 * Returns `true` if a given URI is relative.
 * @param {string} uri
 * @return {Boolean}
 */
function isRelative(uri) {
  return _url2.default.parse(uri).protocol === null;
}

function reporter(context) {
  var _ref3;

  let options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  const Syntax = context.Syntax;
  const getSource = context.getSource;
  const report = context.report;
  const RuleError = context.RuleError;

  const helper = new _textlintRuleHelper.RuleHelper(context);
  const opts = Object.assign({}, DEFAULT_OPTIONS, options);

  /**
   * Checks a given URI's availability and report if it is dead.
   * @param {TextLintNode} node TextLintNode the URI belongs to.
   * @param {string} uri a URI string to be linted.
   * @param {number} index column number the URI is located at.
   */
  const lint = (() => {
    var ref = _asyncToGenerator(function* (_ref) {
      let node = _ref.node;
      let uri = _ref.uri;
      let index = _ref.index;

      if (opts.ignore.indexOf(uri) !== -1) {
        return;
      }

      if (isRelative(uri)) {
        if (!opts.checkRelative) {
          return;
        }

        if (!opts.baseURI) {
          const message = 'The base URI is not specified.';
          report(node, new RuleError(message, { index: 0 }));
          return;
        }

        // eslint-disable-next-line no-param-reassign
        uri = _url2.default.resolve(opts.baseURI, uri);
      }

      var _ref2 = yield isAlive(uri);

      const ok = _ref2.ok;
      const msg = _ref2.message;


      if (!ok) {
        const message = `${ uri } is dead. (${ msg })`;
        report(node, new RuleError(message, { index }));
      }
    });

    return function lint(_x3) {
      return ref.apply(this, arguments);
    };
  })();

  /**
   * URIs to be checked.
   * @type {Array<{ node: TextLintNode, uri: string, index: number }>}
   */
  const URIs = [];

  return _ref3 = {}, _defineProperty(_ref3, Syntax.Str, function (node) {
    if (helper.isChildNode(node, [Syntax.BlockQuote])) {
      return;
    }

    // prevent double checks
    if (helper.isChildNode(node, [Syntax.Link])) {
      return;
    }

    const text = getSource(node);
    let matched;

    // eslint-disable-next-line no-cond-assign
    while (matched = URI_REGEXP.exec(text)) {
      const uri = matched[0];
      const index = matched.index;
      URIs.push({ node, uri, index });
    }
  }), _defineProperty(_ref3, Syntax.Link, function (node) {
    if (helper.isChildNode(node, [Syntax.BlockQuote])) {
      return;
    }

    URIs.push({
      node,
      uri: node.url,
      index: 0
    });
  }), _defineProperty(_ref3, `${ context.Syntax.Document }:exit`, function () {
    return Promise.all(URIs.map(item => lint(item)));
  }), _ref3;
}

exports.default = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=no-dead-link.js.map