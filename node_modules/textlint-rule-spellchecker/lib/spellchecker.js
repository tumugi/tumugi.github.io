'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _textlintRuleHelper = require('textlint-rule-helper');

var _spellchecker = require('spellchecker');

var _spellchecker2 = _interopRequireDefault(_spellchecker);

var _textlintUtilToString = require('textlint-util-to-string');

var _textlintUtilToString2 = _interopRequireDefault(_textlintUtilToString);

var _unistUtilFilter = require('unist-util-filter');

var _unistUtilFilter2 = _interopRequireDefault(_unistUtilFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Exclude inappropriate parts of text from linting,
 * such as link texts, image captions, blockquotes, emphasized texts and inline code.
 * @param {TxtNode} node
 * @param {TextLintContext} context
 * @return {{ source: StringSource, text: string }}
 */
function filterNode(_ref) {
  var node = _ref.node;
  var context = _ref.context;
  var Syntax = context.Syntax;

  var helper = new _textlintRuleHelper.RuleHelper(context);

  if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
    return null;
  }

  var filteredNode = (0, _unistUtilFilter2.default)(node, function (n) {
    return n.type !== Syntax.Code && n.type !== Syntax.Link;
  });

  if (!filteredNode) {
    return null;
  }

  var source = new _textlintUtilToString2.default(filteredNode);
  var text = source.toString();

  return { source: source, text: text };
}

function reporter(context) {
  var Syntax = context.Syntax;
  var report = context.report;
  var RuleError = context.RuleError;
  var fixer = context.fixer;


  return _defineProperty({}, Syntax.Paragraph, function (node) {
    var _ref2 = filterNode({ node: node, context: context }) || {};

    var source = _ref2.source;
    var text = _ref2.text;


    if (!source || !text) {
      return;
    }

    var misspelledCharacterRanges = _spellchecker2.default.checkSpelling(text);

    misspelledCharacterRanges.forEach(function (range) {
      var misspelled = text.slice(range.start, range.end);
      var corrections = _spellchecker2.default.getCorrectionsForMisspelling(misspelled);
      var originalPosition = source.originalPositionFromIndex(range.start);
      var fix = void 0;

      if (corrections.length === 1) {
        var originalRange = [originalPosition.column, originalPosition.column + (range.end - range.start)];

        fix = fixer.replaceTextRange(originalRange, corrections[0]);
      }

      var message = misspelled + ' -> ' + corrections.join(', ');
      report(node, new RuleError(message, {
        line: originalPosition.line - 1,
        column: originalPosition.column,
        fix: fix
      }));
    });
  });
}

exports.default = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=spellchecker.js.map