{"version":3,"sources":["../src/spellchecker.js"],"names":[],"mappings":";;;;;;AAAA;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;AASA,SAAS,UAAT,OAAuC;MAAjB,iBAAiB;MAAX,uBAAW;MAC7B,SAAW,QAAX,OAD6B;;AAErC,MAAM,SAAS,mCAAe,OAAf,CAAT,CAF+B;;AAIrC,MAAI,OAAO,WAAP,CAAmB,IAAnB,EAAyB,CAC3B,OAAO,IAAP,EACA,OAAO,KAAP,EACA,OAAO,UAAP,EACA,OAAO,QAAP,CAJE,CAAJ,EAKI;AACF,WAAO,IAAP,CADE;GALJ;;AASA,MAAM,eAAe,+BAAO,IAAP,EAAa,UAAC,CAAD;WAChC,EAAE,IAAF,KAAW,OAAO,IAAP,IACX,EAAE,IAAF,KAAW,OAAO,IAAP;GAFqB,CAA5B,CAb+B;;AAkBrC,MAAI,CAAC,YAAD,EAAe;AACjB,WAAO,IAAP,CADiB;GAAnB;;AAIA,MAAM,SAAS,mCAAiB,YAAjB,CAAT,CAtB+B;AAuBrC,MAAM,OAAO,OAAO,QAAP,EAAP,CAvB+B;;AAyBrC,SAAO,EAAE,cAAF,EAAU,UAAV,EAAP,CAzBqC;CAAvC;;AA4BA,SAAS,QAAT,CAAkB,OAAlB,EAA2B;MAEvB,SAIE,QAJF,OAFuB;MAGvB,SAGE,QAHF,OAHuB;MAIvB,YAEE,QAFF,UAJuB;MAKvB,QACE,QADF,MALuB;;;AAQzB,6BACG,OAAO,SAAP,YAAkB,MAAM;gBACE,WAAW,EAAE,UAAF,EAAQ,gBAAR,EAAX,KAAiC,EAAjC,CADF;;QACf,sBADe;QACP,kBADO;;;AAGvB,QAAI,CAAC,MAAD,IAAW,CAAC,IAAD,EAAO;AACpB,aADoB;KAAtB;;AAIA,QAAM,4BAA4B,uBAAa,aAAb,CAA2B,IAA3B,CAA5B,CAPiB;;AASvB,8BAA0B,OAA1B,CAAkC,UAAC,KAAD,EAAW;AAC3C,UAAM,aAAa,KAAK,KAAL,CAAW,MAAM,KAAN,EAAa,MAAM,GAAN,CAArC,CADqC;AAE3C,UAAM,cAAc,uBAAa,4BAAb,CAA0C,UAA1C,CAAd,CAFqC;AAG3C,UAAM,mBAAmB,OAAO,yBAAP,CAAiC,MAAM,KAAN,CAApD,CAHqC;AAI3C,UAAI,YAAJ,CAJ2C;;AAM3C,UAAI,YAAY,MAAZ,KAAuB,CAAvB,EAA0B;AAC5B,YAAM,gBAAgB,CACpB,iBAAiB,MAAjB,EACA,iBAAiB,MAAjB,IAA2B,MAAM,GAAN,GAAY,MAAM,KAAN,CAAvC,CAFI,CADsB;;AAM5B,cAAM,MAAM,gBAAN,CAAuB,aAAvB,EAAsC,YAAY,CAAZ,CAAtC,CAAN,CAN4B;OAA9B;;AASA,UAAM,UAAa,sBAAiB,YAAY,IAAZ,CAAiB,IAAjB,CAA9B,CAfqC;AAgB3C,aAAO,IAAP,EAAa,IAAI,SAAJ,CAAc,OAAd,EAAuB;AAClC,cAAM,iBAAiB,IAAjB,GAAwB,CAAxB;AACN,gBAAQ,iBAAiB,MAAjB;AACR,gBAHkC;OAAvB,CAAb,EAhB2C;KAAX,CAAlC,CATuB;IAD3B,CARyB;CAA3B;;kBA4Ce;AACb,UAAQ,QAAR;AACA,SAAO,QAAP","file":"spellchecker.js","sourcesContent":["import { RuleHelper } from 'textlint-rule-helper';\nimport SpellChecker from 'spellchecker';\nimport StringSource from 'textlint-util-to-string';\nimport filter from 'unist-util-filter';\n\n/**\n * Exclude inappropriate parts of text from linting,\n * such as link texts, image captions, blockquotes, emphasized texts and inline code.\n * @param {TxtNode} node\n * @param {TextLintContext} context\n * @return {{ source: StringSource, text: string }}\n */\nfunction filterNode({ node, context }) {\n  const { Syntax } = context;\n  const helper = new RuleHelper(context);\n\n  if (helper.isChildNode(node, [\n    Syntax.Link,\n    Syntax.Image,\n    Syntax.BlockQuote,\n    Syntax.Emphasis,\n  ])) {\n    return null;\n  }\n\n  const filteredNode = filter(node, (n) =>\n    n.type !== Syntax.Code &&\n    n.type !== Syntax.Link\n  );\n\n  if (!filteredNode) {\n    return null;\n  }\n\n  const source = new StringSource(filteredNode);\n  const text = source.toString();\n\n  return { source, text };\n}\n\nfunction reporter(context) {\n  const {\n    Syntax,\n    report,\n    RuleError,\n    fixer,\n  } = context;\n\n  return {\n    [Syntax.Paragraph](node) {\n      const { source, text } = filterNode({ node, context }) || {};\n\n      if (!source || !text) {\n        return;\n      }\n\n      const misspelledCharacterRanges = SpellChecker.checkSpelling(text);\n\n      misspelledCharacterRanges.forEach((range) => {\n        const misspelled = text.slice(range.start, range.end);\n        const corrections = SpellChecker.getCorrectionsForMisspelling(misspelled);\n        const originalPosition = source.originalPositionFromIndex(range.start);\n        let fix;\n\n        if (corrections.length === 1) {\n          const originalRange = [\n            originalPosition.column,\n            originalPosition.column + (range.end - range.start),\n          ];\n\n          fix = fixer.replaceTextRange(originalRange, corrections[0]);\n        }\n\n        const message = `${misspelled} -> ${corrections.join(', ')}`;\n        report(node, new RuleError(message, {\n          line: originalPosition.line - 1,\n          column: originalPosition.column,\n          fix,\n        }));\n      });\n    },\n  };\n}\n\nexport default {\n  linter: reporter,\n  fixer: reporter,\n};\n"]}