{"version":3,"sources":["../src/StringSource.js"],"names":[],"mappings":"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","file":"StringSource.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport ObjectAssign from \"object-assign\";\nimport StructuredSource from \"structured-source\";\nexport default class StringSource {\n    constructor(node) {\n        this.rootNode = node;\n        this.tokenMaps = [];\n        this.generatedString = \"\";\n        // pre calculate\n        this._stringify(this.rootNode);\n        this.originalSource = new StructuredSource(this.rootNode.raw);\n        this.generatedSource = new StructuredSource(this.generatedString);\n        /*\n        [\n        // e.g.) **Str**\n        {\n            // original range\n            // e.g.) [0, 7] = `**Str**`\n            original : [start, end]\n            // intermediate = trim decoration from Original\n            // e.g.) [2, 5]\n            intermediate: [start, end]\n            // generaged value = \"Str\"\n            // e.g.) [0, 3]\n            generated : [start, end]\n        }]\n         */\n    }\n\n    toString() {\n        return this.generatedString;\n    }\n\n    /**\n     * @deprecated use originalIndexFromIndex instead of\n     * @param targetIndex\n     */\n    originalIndexFor(targetIndex) {\n        return this.originalIndexFromIndex(targetIndex);\n    }\n\n    /**\n     * @deprecated use originalPositionFromPosition instead of\n     * @param generatedPosition\n     * @returns {Object}\n     */\n    originalPositionFor(generatedPosition) {\n        return this.originalPositionFromPosition(generatedPosition);\n    }\n\n    /**\n     * Pass (generated)index value and return original index value.\n     * @param {number} generatedIndex - position is a index value.\n     * @returns {number|undefined} original\n     */\n    originalIndexFromIndex(generatedIndex) {\n        let hitTokenMaps = this.tokenMaps.filter(tokenMap => {\n            let generated = tokenMap.generated;\n            if (generated[0] <= generatedIndex && generatedIndex < generated[1]) {\n                return true;\n            }\n        });\n        if (hitTokenMaps.length === 0) {\n            return;\n        }\n        // a bcd\n        // b = index 1\n        // original `a` bcd\n        // originalRange [3, 7]\n        // adjustedStart = 1\n        // b's index = 3 + 1\n        let hitTokenMap = hitTokenMaps[0];\n        // <----------->\\[<------------->|text]\n        //              ^        ^\n        //   position-generated  intermediate-origin\n        let outAdjust = generatedIndex - hitTokenMap.generated[0];\n        let inAdjust = hitTokenMap.intermediate[0] - hitTokenMap.original[0];\n        return outAdjust + inAdjust + hitTokenMap.original[0];\n    }\n\n    /**\n     * Pass generated position and return original position.\n     * @param {object} position\n     * @returns {object} original position\n     */\n    originalPositionFromPosition(position) {\n        if (typeof position.line === \"undefined\" || typeof position.column === \"undefined\") {\n            throw new Error(\"position.{line, column} should not undefined: \" + JSON.stringify(position));\n        }\n        var generatedIndex = this.generatedSource.positionToIndex(position);\n        if (isNaN(generatedIndex)) {\n            // Not Found\n            return;\n        }\n        let originalIndex = this.originalIndexFromIndex(generatedIndex);\n        return this.originalSource.indexToPosition(originalIndex);\n    }\n\n    originalIndexFromPosition(generatedPosition) {\n        const originalPosition = this.originalPositionFromPosition(generatedPosition);\n        return this.originalSource.positionToIndex(originalPosition);\n    }\n\n    originalPositionFromIndex(generatedIndex) {\n        let originalIndex = this.originalIndexFromIndex(generatedIndex);\n        return this.originalSource.indexToPosition(originalIndex);\n    }\n\n\n    isParagraphNode(node) {\n        return node.type === \"Paragraph\";\n    }\n\n    isStringNode(node) {\n        return node.type === \"Str\";\n    }\n\n    _getValue(node) {\n        if (node.value) {\n            return node.value;\n        } else if (node.alt) {\n            return node.alt;\n        } else if (node.title) {\n            return node.title;\n        }\n    }\n\n    _nodeRangeAsRelative(node) {\n        // relative from root\n        return [\n            node.range[0] - this.rootNode.range[0],\n            node.range[1] - this.rootNode.range[0]\n        ]\n    }\n\n    _valueOf(node, parent) {\n        if (!node) {\n            return;\n        }\n\n\n        // [padding][value][padding]\n        // =>\n        // [value][value][value]\n        let value = this._getValue(node);\n        if (!value) {\n            return;\n        }\n        if (parent == null) {\n            return;\n        }\n        // <p><Str /></p>\n        if (this.isParagraphNode(parent) && this.isStringNode(node)) {\n            return {\n                original: this._nodeRangeAsRelative(node),\n                intermediate: this._nodeRangeAsRelative(node),\n                value: value\n            };\n        }\n        // <p><code>code</code></p>\n        // => container is <p>\n        // <p><strong><Str /></strong></p>\n        // => container is <strong>\n        let container = this.isParagraphNode(parent) ? node : parent;\n        let rawValue = container.raw;\n        // avoid match ! with ![\n        // TODO: indexOf(value, 1) 1 is unexpected ...\n        let paddingLeft = rawValue.indexOf(value, 1);\n        let paddingRight = rawValue.length - (paddingLeft + value.length);\n        // original range should be relative value from rootNode\n        let originalRange = this._nodeRangeAsRelative(container);\n        let intermediateRange = [\n            originalRange[0] + paddingLeft,\n            originalRange[1] - paddingRight\n        ];\n        return {\n            original: originalRange,\n            intermediate: intermediateRange,\n            value: value\n        };\n\n    }\n\n    _addTokenMap(tokenMap) {\n        if (tokenMap == null) {\n            return;\n        }\n        let addedTokenMap = ObjectAssign({}, tokenMap);\n        if (this.tokenMaps.length === 0) {\n            let textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];\n            addedTokenMap[\"generated\"] = [0, textLength];\n        } else {\n            let textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];\n            addedTokenMap[\"generated\"] = [this.generatedString.length, this.generatedString.length + textLength];\n        }\n        this.generatedString += tokenMap.value;\n        this.tokenMaps.push(addedTokenMap);\n    }\n\n    /**\n     * Compute text content of a node.  If the node itself\n     * does not expose plain-text fields, `toString` will\n     * recursivly try its children.\n     *\n     * @param {Node} node - Node to transform to a string.\n     * @param {Node} [parent] - Parent Node of the `node`.\n     */\n    _stringify(node, parent) {\n        let value = this._valueOf(node, parent);\n        if (value) {\n            return value;\n        }\n        if (!node.children) {\n            return;\n        }\n        node.children.forEach((childNode) => {\n            let tokenMap = this._stringify(childNode, node);\n            if (tokenMap) {\n                this._addTokenMap(tokenMap);\n            }\n        });\n    }\n}\n"]}