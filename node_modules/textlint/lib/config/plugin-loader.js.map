{"version":3,"sources":["../../src/config/plugin-loader.js"],"names":[],"mappings":";AACA;;;;;QAKgB,c,GAAA,c;QAiBA,e,GAAA,e;QAeA,uB,GAAA,uB;;;;AApChB,IAAM,iBAAiB,QAAQ,iBAAR,CAAvB;AACA,IAAM,eAAe,QAAQ,eAAR,CAArB;AACA,IAAM,QAAQ,QAAQ,OAAR,EAAiB,wBAAjB,CAAd;AACA,IAAM,SAAS,QAAQ,QAAR,CAAf;AACO,SAAS,cAAT,CAAwB,WAAxB,EAAqC,UAArC,EAAiD;AACpD,QAAM,SAAS,EAAf;AACA,QAAI,gBAAgB,SAApB,EAA+B;AAC3B,eAAO,MAAP;AACH;AACD,WAAO,IAAP,CAAY,WAAZ,EAAyB,OAAzB,CAAiC,eAAO;AACpC,eAAU,UAAV,SAAwB,GAAxB,IAAiC,YAAY,GAAZ,CAAjC;AACH,KAFD;AAGA,WAAO,MAAP;AACH;;;;;;;;AAQM,SAAS,eAAT,GAA2D;AAAA,QAAlC,WAAkC,yDAApB,EAAoB;AAAA,QAAhB,cAAgB;;AAC9D,QAAM,oBAAoB,EAA1B;AACA,gBAAY,OAAZ,CAAoB,sBAAc;AAC9B,YAAM,UAAU,eAAe,wBAAf,CAAwC,UAAxC,CAAhB;AACA,YAAM,SAAS,eAAe,OAAf,CAAf;AACA,YAAI,CAAC,OAAO,cAAP,CAAsB,aAAtB,CAAL,EAA2C;AACvC;AACH;AACD,cAAS,UAAT;;AAEA,qBAAa,iBAAb,EAAgC,eAAe,OAAO,WAAtB,EAAmC,UAAnC,CAAhC;AACH,KATD;AAUA,WAAO,iBAAP;AACH;;AAEM,SAAS,uBAAT,GAAmE;AAAA,QAAlC,WAAkC,yDAApB,EAAoB;AAAA,QAAhB,cAAgB;;AACtE,QAAM,sBAAsB,EAA5B;AACA,gBAAY,OAAZ,CAAoB,sBAAc;AAC9B,YAAM,UAAU,eAAe,wBAAf,CAAwC,UAAxC,CAAhB;AACA,YAAM,SAAS,eAAe,OAAf,CAAf;AACA,YAAI,CAAC,OAAO,cAAP,CAAsB,WAAtB,CAAL,EAAyC;AACrC;AACH;AACD,YAAM,YAAY,OAAO,SAAzB;AACA,cAAS,UAAT;AACA,eAAO,OAAO,UAAU,mBAAjB,KAAyC,UAAhD,EAA4D,uDAA5D;AACA,4BAAoB,IAApB,+CAA4B,UAAU,mBAAV,EAA5B;AACH,KAVD;AAWA,WAAO,mBAAP;AACH","file":"plugin-loader.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst interopRequire = require(\"interop-require\");\nconst ObjectAssign = require(\"object-assign\");\nconst debug = require(\"debug\")(\"textlint:plugin-loader\");\nconst assert = require(\"assert\");\nexport function mapRulesConfig(rulesConfig, pluginName) {\n    const mapped = {};\n    if (rulesConfig === undefined) {\n        return mapped;\n    }\n    Object.keys(rulesConfig).forEach(key => {\n        mapped[`${pluginName}/${key}`] = rulesConfig[key];\n    });\n    return mapped;\n}\n// load rulesConfig from plugins\n/**\n *\n * @param pluginNames\n * @param {TextLintModuleResolver} moduleResolver\n * @returns {{}}\n */\nexport function loadRulesConfig(pluginNames = [], moduleResolver) {\n    const pluginRulesConfig = {};\n    pluginNames.forEach(pluginName => {\n        const pkgPath = moduleResolver.resolvePluginPackageName(pluginName);\n        const plugin = interopRequire(pkgPath);\n        if (!plugin.hasOwnProperty(\"rulesConfig\")) {\n            return;\n        }\n        debug(`${pluginName} has rulesConfig`);\n        // set config of <rule> to \"<plugin>/<rule>\"\n        ObjectAssign(pluginRulesConfig, mapRulesConfig(plugin.rulesConfig, pluginName));\n    });\n    return pluginRulesConfig;\n}\n\nexport function loadAvailableExtensions(pluginNames = [], moduleResolver) {\n    const availableExtensions = [];\n    pluginNames.forEach(pluginName => {\n        const pkgPath = moduleResolver.resolvePluginPackageName(pluginName);\n        const plugin = interopRequire(pkgPath);\n        if (!plugin.hasOwnProperty(\"Processor\")) {\n            return;\n        }\n        const Processor = plugin.Processor;\n        debug(`${pluginName} has Processor`);\n        assert(typeof Processor.availableExtensions === \"function\", \"Processor.availableExtensions() should be implemented\");\n        availableExtensions.push(...Processor.availableExtensions());\n    });\n    return availableExtensions;\n}\n"]}