{"version":3,"sources":["../../src/fixer/source-code-fixer.js"],"names":[],"mappings":"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","file":"source-code-fixer.js","sourcesContent":["const debug = require(\"debug\")(\"textlint:source-code-fixer\");\nimport SourceCode from \"../core/source-code\";\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by line and column.\n * @param {TextLintMessage} a The first message.\n * @param {TextLintMessage} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    const lineDiff = a.line - b.line;\n\n    if (lineDiff === 0) {\n        return a.column - b.column;\n    } else {\n        return lineDiff;\n    }\n}\n\nfunction clone(object) {\n    return JSON.parse(JSON.stringify(object));\n}\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\n\nexport default class SourceCodeFixer {\n    /**\n     * Applies the fixes specified by the messages to the given text. Tries to be\n     * smart about the fixes and won't apply fixes over the same area in the text.\n     * @param {SourceCode} sourceCode The source code to apply the changes to.\n     * @param {TextLintMessage[]} messages The array of messages reported by ESLint.\n     * @returns {Object} An object containing the fixed text and any unfixed messages.\n     */\n    static applyFixes(sourceCode, messages) {\n        debug(\"Applying fixes\");\n        const text = sourceCode.text;\n        // As as result, show diff\n        const remainingMessages = [];\n        const applyingMessages = [];\n        const cloneMessages = messages.slice();\n        const fixes = [];\n        let lastFixPos = text.length + 1;\n        let prefix = (sourceCode.hasBOM ? BOM : \"\");\n        cloneMessages.forEach(problem => {\n            if (problem && problem.hasOwnProperty(\"fix\")) {\n                fixes.push(problem);\n            } else {\n                remainingMessages.push(problem);\n            }\n        });\n\n        if (fixes.length) {\n            debug(\"Found fixes to apply\");\n\n            // sort in reverse order of occurrence\n            fixes.sort((a, b) => {\n                if (a.fix.range[1] <= b.fix.range[0]) {\n                    return 1;\n                } else {\n                    return -1;\n                }\n            });\n\n            // split into array of characters for easier manipulation\n            const chars = text.split(\"\");\n\n            fixes.forEach(problem => {\n                // pickup fix range\n                const fix = problem.fix;\n                let start = fix.range[0];\n                const end = fix.range[1];\n                let insertionText = fix.text;\n\n                if (end < lastFixPos) {\n                    if (start < 0) {\n                        // Remove BOM.\n                        prefix = \"\";\n                        start = 0;\n                    }\n                    if (start === 0 && insertionText[0] === BOM) {\n                        // Set BOM.\n                        prefix = BOM;\n                        insertionText = insertionText.slice(1);\n                    }\n\n                    const replacedChars = chars.splice(start, end - start, insertionText);\n                    lastFixPos = start;\n                    const copyOfMessage = clone(problem);\n                    copyOfMessage.fix = {\n                        range: [start, start + insertionText.length],\n                        text: replacedChars.join(\"\")\n                    };\n                    applyingMessages.push(copyOfMessage);\n                } else {\n                    remainingMessages.push(problem);\n                }\n            });\n\n            return {\n                fixed: true,\n                messages: cloneMessages,// have order\n                applyingMessages: applyingMessages.reverse(),// have order\n                remainingMessages: remainingMessages.sort(compareMessagesByLocation),// have not order\n                output: prefix + chars.join(\"\")\n            };\n        } else {\n            debug(\"No fixes to apply\");\n            return {\n                fixed: false,\n                messages: cloneMessages,\n                applyingMessages,\n                remainingMessages,\n                output: prefix + text\n            };\n        }\n    }\n\n    /**\n     * Sequentially Applies the fixes specified by the messages to the given text.\n     * @param {SourceCode} sourceCode The source code to apply the changes to.\n     * @param {TextLintMessage[]} applyingMessages The array of TextLintMessage reported by SourceCodeFixer#applyFixes\n     * @returns {string} An object containing the fixed text and any unfixed messages.\n     */\n    static sequentiallyApplyFixes(sourceCode, applyingMessages) {\n        debug(\"Restore applied fixes\");\n        let text = sourceCode.text;\n        applyingMessages.forEach(message => {\n            const newSource = new SourceCode({\n                text,\n                ast: sourceCode.ast, // it's dummy\n                ext: sourceCode.ext,\n                filePath: sourceCode.filePath\n            });\n            const result = SourceCodeFixer.applyFixes(newSource, [message]);\n            text = result.output;\n        });\n        return text;\n    }\n}\n"]}