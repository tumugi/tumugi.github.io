{"version":3,"sources":["../src/textlint-core.js"],"names":[],"mappings":"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","file":"textlint-core.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\n/*\n textlint-core.js is a class\n textlint.js is a singleton object that is instance of textlint-core.js.\n */\nconst path = require(\"path\");\nconst assert = require(\"assert\");\nimport {readFile} from \"./util/fs-promise\";\nimport SourceCode from \"./core/source-code\";\nimport {getProcessorMatchExtension} from \"./util/proccesor-helper\";\nimport {Processor as MarkdownProcessor} from \"textlint-plugin-markdown\";\nimport {Processor as TextProcessor} from \"textlint-plugin-text\";\nimport RuleCreatorSet from \"./core/rule-creator-set\";\n// = Processors\n// sequence\nimport FixerProcessor from \"./fixer/fixer-processor\";\n// parallel\nimport LinterProcessor from \"./linter/linter-processor\";\n\n/**\n * add fileName to trailing of error message\n * @param {string|undefined} fileName\n * @param {string} message\n * @returns {string}\n */\nfunction addingAtFileNameToError(fileName, message) {\n    if (!fileName) {\n        return message;\n    }\n    return `${message}\nat ${fileName}`;\n\n}\n/**\n * @class {TextlintCore}\n */\nexport default class TextlintCore {\n    constructor(config = {}) {\n        // this.config often is undefined.\n        this.config = config;\n        this.ruleCreatorSet = new RuleCreatorSet();\n        // Markdown and Text are for backward compatibility.\n        // FIXME: in the future, this.processors is empty by default.\n        this._defaultProcessors = [\n            new MarkdownProcessor(config),\n            new TextProcessor(config)\n        ];\n        this.processors = this._defaultProcessors.slice();\n    }\n\n    /**\n     * unstable API\n     * @param Processor\n     * @private\n     */\n    addProcessor(Processor) {\n        // add first\n        this.processors.unshift(new Processor(this.config));\n    }\n\n    /**\n     * register Processors\n     * @param {Object} processors\n     */\n    setupProcessors(processors = {}) {\n        this.processors.length = 0;\n        Object.keys(processors).forEach(key => {\n            const Processor = processors[key];\n            this.addProcessor(Processor);\n        });\n        this.processors = this.processors.concat(this._defaultProcessors);\n    }\n\n\n    /**\n     * Register rules and rulesConfig.\n     * if want to release rules, please call {@link resetRules}.\n     * @param {object} rules rule objects array\n     * @param {object} [rulesConfig] ruleConfig is object\n     */\n    setupRules(rules = {}, rulesConfig = {}) {\n        this.ruleCreatorSet = new RuleCreatorSet(rules, rulesConfig);\n    }\n\n    /**\n     * Remove all registered rule and clear messages.\n     */\n    resetRules() {\n        this.ruleCreatorSet = new RuleCreatorSet();\n    }\n\n    /**\n     * process text in parallel for Rules and return {Promise.<TextLintResult>}\n     * In other word, parallel flow process.\n     * @param processor\n     * @param text\n     * @param ext\n     * @param filePath\n     * @returns {Promise.<TextLintResult>}\n     * @private\n     */\n    _parallelProcess(processor, text, ext, filePath) {\n        assert(processor, `processor is not found for ${ext}`);\n        const {preProcess, postProcess} = processor.processor(ext);\n        assert(typeof preProcess === \"function\" && typeof postProcess === \"function\",\n            \"processor should implement {preProcess, postProcess}\");\n        const ast = preProcess(text, filePath);\n        const sourceCode = new SourceCode({\n            text,\n            ast,\n            ext,\n            filePath\n        });\n        const linterProcessor = new LinterProcessor(processor);\n        return linterProcessor.process({\n            config: this.config,\n            ruleCreatorSet: this.ruleCreatorSet,\n            sourceCode: sourceCode\n        }).catch(error => {\n            error.message = addingAtFileNameToError(filePath, error.message);\n            return Promise.reject(error);\n        });\n    }\n\n    /**\n     * lint text by registered rules.\n     * The result contains target filePath and error messages.\n     * @param {string} text\n     * @param {string} ext ext is extension. default: .txt\n     * @returns {Promise.<TextLintResult>}\n     */\n    lintText(text, ext = \".txt\") {\n        const processor = getProcessorMatchExtension(this.processors, ext);\n        return this._parallelProcess(processor, text, ext);\n    }\n\n    /**\n     * lint markdown text by registered rules.\n     * The result contains target filePath and error messages.\n     * @param {string} text markdown format text\n     * @returns {Promise.<TextLintResult>}\n     */\n    lintMarkdown(text) {\n        const ext = \".md\";\n        return this.lintText(text, ext);\n    }\n\n    /**\n     * lint file and return result object\n     * @param {string} filePath\n     * @returns {Promise.<TextLintResult>} result\n     */\n    lintFile(filePath) {\n        const absoluteFilePath = path.resolve(process.cwd(), filePath);\n        const ext = path.extname(absoluteFilePath);\n        return readFile(absoluteFilePath).then(text => {\n            const processor = getProcessorMatchExtension(this.processors, ext);\n            return this._parallelProcess(processor, text, ext, absoluteFilePath);\n        });\n    }\n\n    /**\n     * fix file and return fix result object\n     * @param {string} filePath\n     * @returns {Promise.<TextLintFixResult>}\n     */\n    fixFile(filePath) {\n        const absoluteFilePath = path.resolve(process.cwd(), filePath);\n        const ext = path.extname(absoluteFilePath);\n        return readFile(absoluteFilePath).then(text => {\n            const processor = getProcessorMatchExtension(this.processors, ext);\n            return this._sequenceProcess(processor, text, ext, absoluteFilePath);\n        });\n    }\n\n    /**\n     * fix texts and return fix result object\n     * @param {string} text\n     * @param {string} ext\n     * @returns {Promise.<TextLintFixResult>}\n     */\n    fixText(text, ext = \".txt\") {\n        const processor = getProcessorMatchExtension(this.processors, ext);\n        return this._sequenceProcess(processor, text, ext);\n    }\n\n    /**\n     * process text in series for Rules and return {Promise.<TextLintFixResult>}\n     * In other word, sequence flow process.\n     * @param processor\n     * @param text\n     * @param ext\n     * @param filePath\n     * @returns {Promise.<TextLintFixResult>}\n     * @private\n     */\n    _sequenceProcess(processor, text, ext, filePath) {\n        assert(processor, `processor is not found for ${ext}`);\n        const {preProcess, postProcess} = processor.processor(ext);\n        assert(typeof preProcess === \"function\" && typeof postProcess === \"function\",\n            \"processor should implement {preProcess, postProcess}\");\n        const ast = preProcess(text, filePath);\n        const sourceCode = new SourceCode({\n            text,\n            ast,\n            ext,\n            filePath\n        });\n        const fixerProcessor = new FixerProcessor(processor);\n        return fixerProcessor.process({\n            config: this.config,\n            ruleCreatorSet: this.ruleCreatorSet,\n            sourceCode: sourceCode\n        }).catch(error => {\n            error.message = addingAtFileNameToError(filePath, error.message);\n            return Promise.reject(error);\n        });\n    }\n}\n"]}